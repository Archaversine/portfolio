<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Adam Brohl - Implementing Game of Life with Comonads</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Adam Brohl</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Implementing Game of Life with Comonads</h1>
            <article>
    <section class="header">
        Posted on October 28, 2025
        
            by Adam Brohl
        
    </section>
    <section>
        <p>One of the most highly associated words in Haskell is <em>monad</em>, and for good
reason too. Without monads, programming in Haskell would be extremely tedious,
and a lot of generalized abstractions wouldn’t even exist. But there is a lot
more to Haskell than just monads. As you might expect from the title of this
post, I am talking about comonads. There are already multiple posts explaining
comonads, and especially how to model Conway’s Game of Life with them, but I
personally found them to be more technical and offer little to no intuitive
explanations. Hopefully this post provides that.</p>
<h2 id="what-is-a-comonad">What is a Comonad?</h2>
<p>First, what exactly is a comonad. The most often used definition I see people
give to this quesion is that it is, “the dual of a monad.” If you are not well
versed in category theory, I find this explanation to be a bit lacking. Lets
examine exactly what that means. In Haskell, we can define the <code>Monad</code>
typeclass is like so:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>Intuitively, we can think of the <code>(&gt;&gt;=)</code> operater as something that:</p>
<ul>
<li>Takes in a value <code>a</code> in some context <code>m</code></li>
<li>Takes in a function that acts on an <code>a</code> and returns <code>b</code> in a context <code>m</code></li>
<li>Returns a <code>b</code> in context <code>m</code>.</li>
</ul>
<p>When we take the dual of monad, what we actually do in Haskell is reverse the
direction of the arrows to something like: <code>m a &lt;- (a &lt;- m b) &lt;- m b</code>. We can
flip the expression around by pointing the arrows to the right instead of the
left and get: <code>m b -&gt; (m b -&gt; a) -&gt; m a</code>. We can also swap <code>b</code> and <code>a</code> so that
<code>a</code> appears first, which we can do because they are both type variables, and
get: <code>m a -&gt; (m a -&gt; b) -&gt; m b</code>. And finally, a comonad is typically represented
by <code>w</code> instead of <code>m</code> (where the <code>w</code> is a horizontally mirrored <code>m</code>), so we can
rewrite it as: <code>w a -&gt; (w a -&gt; b) -&gt; w b</code>. And this new function is the dual
of bind, named <code>extend</code>.</p>
<p>Due to some technical reasons beyond the scope of this post, there is no
coapplicative class in Haskell. Instead, one typically tries to define all the
relevant functions inside the <code>Comonad</code> typelcass. So lets look at the three
functions from <code>Monad</code> we’ll need to compute the duals of:</p>
<ul>
<li><code>(&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</code></li>
<li><code>join   :: m (m a) -&gt; m a</code></li>
<li><code>return :: a -&gt; m a</code></li>
</ul>
<p><code>join</code> and <code>return</code> are relatively easy to compute the duals of, as we just
use the same process as before:</p>
<ul>
<li><code>cojoin   :: w a -&gt; w (w a)</code></li>
<li><code>coreturn :: w a -&gt; a</code></li>
</ul>
<p>While <code>cojoin</code> and <code>coreturn</code> are used in some places, they often go by
more intuitive names. <code>cojoin</code> is usually referred to as <code>duplicate</code>, and
<code>coreturn</code> is typically called <code>extract</code>. I will use the latter in both cases.
It is also worth noting that the dual of <code>(&gt;&gt;=)</code> is named <code>(=&gt;&gt;)</code>. Putting
these all together, we can finally write code for the <code>Comonad</code> typeclass:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (=&gt;&gt;)     ::</span> w a <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    extract   ::</span> w a <span class="ot">-&gt;</span> a </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span></code></pre></div>
<p><em>Note: <code>duplicate</code> and <code>extend</code> (<code>=&gt;&gt;</code>) can actually be defined in terms of
each other. So when creating a comonad instance, you typically only define
2 out of the three functions.</em></p>
<p>All of these will be explained in more further detail further on. But for now,
Intuitively, we could think of the each of the following intuition-based
explanations for all the comonad functions:</p>
<ul>
<li><code>(=&gt;&gt;)</code>: This function takes in an <code>a</code> in some context <code>w</code>, and a function
that maps from a <code>w a</code> to some value <code>b</code>, and returns a <code>b</code> in some context.</li>
<li><code>extract</code>: This function <em>extracts</em> an <code>a</code> out of some context <code>w</code>.</li>
<li><code>duplicate</code>: This function <em>duplicates</em> the context <code>w</code> of <code>a</code>.</li>
</ul>
<h3 id="real-world-example">Real World Example</h3>
<p>A real life example of a comonad that really stuck with me was a HDD.
Internally, an HDD can contain terabytes of information, but accesses singular
points of the data using a type of needle. Here, the <code>extract</code> function would
read the data the needle is currently pointing to, the <code>duplicate</code> function
would treat each individually point as an HDD centered around that point, and
the <code>(=&gt;&gt;)</code> operator can be thought of something that takes an HDD on the left
side, and a formula which may use information from anywhere on the drive that
yields a single value, which will result in a new HDD with that formula applied
to every point.</p>
<h3 id="store-comonad">Store Comonad</h3>
<p>The <code>comonad</code> library implements a comonad for us that behaves in a very similar
way: the <code>Store</code> comonad. In its simplest form, the <code>Store</code> comonad is
implemented as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> {<span class="ot"> peek ::</span> s <span class="ot">-&gt;</span> a,<span class="ot"> pos ::</span> s }</span></code></pre></div>
<p>The <code>peek</code> value represents a function that takes in some index of type <code>s</code>,
and returns a value of type <code>a</code>. The <code>pos</code> function returns the current index.
In terms of the previous HDD example, <code>pos</code> represents where the needle is
currently pointing to.</p>
<p>After defining a <code>Functor</code> instance, we can than define a <code>Comonad</code> instance:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> {<span class="ot"> peek ::</span> s <span class="ot">-&gt;</span> a,<span class="ot"> pos ::</span> s } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    extract st   <span class="ot">=</span> peek st (pos st)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    duplicate st <span class="ot">=</span> <span class="dt">Store</span> (\s <span class="ot">-&gt;</span> <span class="dt">Store</span> (peek st) s) (pos st)</span></code></pre></div>
<p>Extracting a value is as simple as peeking at the current position of the store.
Duplicating the store requires redefining the <code>peek</code> function in such a way
that indexing with <code>s</code> returns a store whose position is set at <code>s</code>.</p>
<h2 id="conways-game-of-life">Conway’s Game of Life</h2>
<p>Conway’s Game of Life is an incredibly simple simulation containing a grid of
cells which only have two states: alive and dead. The state of each cell is
entirely dependent (except for the initial states which are provided by the
user) on their adjacent neighbors. In other words, the value of each cell can
be extracted from the context (i.e. the board), which is exactly what the two
previous examples covered.</p>
<h3 id="grid-type">Grid Type</h3>
<p>Due to performance reasons, I will not be using the <code>Store</code> type that comes
in the <code>comonad</code> library. Instead, I will be creating a new datatype that
resembles it very closely, and even create an instance of the <code>ComonadStore</code>
typeclass for the new type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Grid</span> a <span class="ot">=</span> <span class="dt">Grid</span> <span class="op">!</span>(<span class="dt">Vector</span> (<span class="dt">Vector</span> a)) (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>As one might assume, the <code>Grid</code> type will be the comonad that represents the
state of all cells in the simulation. The datatype consists of two main parts.
The first is the actual array of cells, which is encoded as a vector of vectors,
and the second is a tuple of integers, which represents the location in the
array that is currently “selected”. This is very similar to the <code>Store</code> comonad
except instead of having an indexing function, we carry around the thing we are
indexing. Now, we can define an instance of <code>Comonad</code> for our new <code>Grid</code> type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Grid</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    extract   (<span class="dt">Grid</span> xs (x, y)) <span class="ot">=</span> xs <span class="op">!</span> x <span class="op">!</span> y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    duplicate (<span class="dt">Grid</span> xs (x, y)) <span class="ot">=</span> <span class="dt">Grid</span> duplicated (x, y)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span> duplicated <span class="ot">=</span> <span class="fu">fmap</span> (\(x', v)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                            <span class="ot">-&gt;</span> <span class="fu">fmap</span> (\(y', _)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                                <span class="ot">-&gt;</span> <span class="dt">Grid</span> xs (x', y')) (Vector.indexed v))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                            (Vector.indexed xs)</span></code></pre></div>
<p>The <code>extract</code> function is trivial; it simply retrieves the values at the stored
pair of indices. The <code>duplicate</code> function is implemented in a very similar way
to the <code>Store</code> comonad, where each element of the original array becomes a vector
centered around that particular index.</p>
<p>I also mentioned the <code>ComonadStore</code> typeclass. This is similar to something
like <code>MonadState</code> where the <code>get</code> and <code>put</code> can be defined for monads other
than <code>State</code>. We will use this to be able to use the <code>peek</code> and <code>pos</code> functions
on our <code>Grid</code> type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ComonadStore</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Grid</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    pos (<span class="dt">Grid</span> _ p) <span class="ot">=</span> p</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    peek (x, y) (<span class="dt">Grid</span> xs _) <span class="ot">=</span> xs <span class="op">!</span> x <span class="op">!</span> y </span></code></pre></div>
<h3 id="implementing-the-game">Implementing the Game</h3>
<p>Now that we have our underlying <code>Grid</code> type, we can actually start implmeneting
the rest of the game, which is now shockingly easy. First, we need a function
which computes all adjacent locations for an arbitrary given location. I’ve
defined two helper functions that do just that:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gridSize ::</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>gridSize <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">adjacentOffsets ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>adjacentOffsets <span class="ot">=</span> [(x, y) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], y <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], (x, y) <span class="op">/=</span> (<span class="dv">0</span>, <span class="dv">0</span>)]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">neighbors ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>neighbors (x, y) <span class="ot">=</span> [ (x', y')</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> (dx, dy) <span class="ot">&lt;-</span> adjacentOffsets</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                   , <span class="kw">let</span> x' <span class="ot">=</span> x <span class="op">+</span> dx</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                   , <span class="kw">let</span> y' <span class="ot">=</span> y <span class="op">+</span> dy</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                   , x' <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> x' <span class="op">&lt;</span> gridSize</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                   , y' <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> y' <span class="op">&lt;</span> gridSize</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                   ]</span></code></pre></div>
<p><em>Note: The <code>neighbors</code> function filters out any invalid locations, so we don’t
have to worry about indexing in an unsafe way.</em></p>
<p>And finally, some helper functions for working with our grid type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">printGrid ::</span> <span class="dt">Grid</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>printGrid (<span class="dt">Grid</span> xs _) <span class="ot">=</span> <span class="fu">mapM_</span> printRow xs</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> printRow row <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> intersperse <span class="ch">' '</span> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                                  <span class="op">$</span> <span class="fu">map</span> (bool <span class="ch">'.'</span> <span class="ch">'#'</span>) (Vector.toList row)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">gridFromSquares ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)] <span class="ot">-&gt;</span> <span class="dt">Grid</span> <span class="dt">Bool</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>gridFromSquares xs <span class="ot">=</span> <span class="dt">Grid</span> grid (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> grid <span class="ot">=</span> Vector.generate gridSize</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                    (\x <span class="ot">-&gt;</span> Vector.generate gridSize (\y <span class="ot">-&gt;</span> (x, y) <span class="ot">`elem`</span> xs))</span></code></pre></div>
<p>The <code>gridFromSquares</code> function takes in a list of squares that should start
as active, and then generate the corresponding 2D vector. We are also using
<code>Grid Bool</code> as the actual type of the board, where <code>True</code> represents alive and
<code>False</code> represents dead.</p>
<p>Now, we can define the actual logic for the game that specifies what the state
of a square should be for the next iteration. The game of life has a very
simple set of rules:</p>
<ul>
<li>If a cell is currently alive, it will remain alive as long as there are at
least 2 neighboring living cells and at most 3 neighboring cells. Otherwise,
it will die.</li>
<li>If a cell is not currently alive, then it will <em>only</em> become alive if there
are exactly three neighboring cells that are alive.</li>
</ul>
<p>We can represent this logic as a function that takes in a grid, and returns
the state for the currently selected cell:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">step ::</span> <span class="dt">Grid</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>step grid <span class="ot">=</span> <span class="kw">if</span> self <span class="kw">then</span> ns <span class="ot">`elem`</span> [<span class="dv">2</span>, <span class="dv">3</span>] <span class="kw">else</span> ns <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> ns   <span class="ot">=</span> <span class="fu">length</span> <span class="op">$</span> <span class="fu">filter</span> (<span class="fu">flip</span> peek grid) <span class="op">$</span> neighbors (pos grid)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>          self <span class="ot">=</span> peek (pos grid) grid <span class="co">-- current cell state</span></span></code></pre></div>
<p>Notice the type signature of <code>step</code>. It fits perfectly into the <code>(=&gt;&gt;)</code> operator
that we defined earlier for comonads. And this was done on purpose. Lets see
what happens when we use this function on a grid.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> grid <span class="ot">=</span> gridFromSquares [(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">3</span>), (<span class="dv">5</span>, <span class="dv">5</span>)]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    printGrid grid</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    printGrid (grid <span class="op">=&gt;&gt;</span> step)</span></code></pre></div>
<p>We will get the following output to the screen:</p>
<pre><code>. . . . . . . . . . . . . . . . . . . .
. # # . . . . . . . . . . . . . . . . .
. . # . . . . . . . . . . . . . . . . .
. . . # . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . # . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . .
. # # . . . . . . . . . . . . . . . . .
. # # # . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .</code></pre>
<p>And by the magic of the comonad, everything works. We can see that some of our
initial cells stayed active because they had a sufficient amount of adjacent
living neighbors, two of them died off because they were too isolated, and two
cells switched to alive because there were enough living neighbors nearby. Why
does this work? This works because when we use the <code>extend</code> function <code>(=&gt;&gt;)</code>
the <code>Grid</code> type is duplicated to a <code>Grid (Grid Bool)</code>, and then our <code>step</code>
function is mapped via <code>fmap</code> to cause each inner <code>Grid Bool</code> to collapse back
into a <code>Bool</code>.</p>
    </section>
</article>

        </main>

        <footer>
            Site <em>proudly</em> generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
